#include "game.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/start.h"
#include "images/enemyPic.h"
#include "images/enemyPic2.h"
#include "images/nonEnemy.h"
#include "images/end.h"



/* TODO: */
// Add any additional states you need for your app.
typedef enum {
  START,
  PLAY,
  WIN,
  LOSE,
  STARTWAIT,
} GBAState;

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
    REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial game state
  GBAState state = START;

  struct enemy finalEnemy;
  struct enemy finalEnemy2;
  {
    /* data */
  };
  
  struct enemy noDamageEnemy1;
  struct enemy noDamageEnemy2;
  struct enemy noDamageEnemy3;
  {
    /* data */
  };
  

  {
    /* data */
  };
  

  while (1) {
    waitForVBlank();
    currentButtons = BUTTONS;  // Load the current state of the buttons

    switch (state) {
      case START:
      //setting the various attriubutes of nonEnemy, state, finalEnemy 
        ax.nonEnemy.x = 0;
        ax.nonEnemy.y= 100;
        ax.nonEnemy.height = 20; //make sure values look good on the scrren 
        ax.nonEnemy.width = 20; 
        ax.win = 0;
        ax.lose = 0;
        ax.select = 0;
        ax.nonEnemy.movesToEnd = 0;

        //Enemy 1 that can harm you - red
        finalEnemy.x = 120;
        finalEnemy.y = 120;
        finalEnemy.width = 20;
        finalEnemy.height = 20;

        //Enemy 2 that can harm you - red
        finalEnemy2.x = 120;
        finalEnemy2.y = 120;
        finalEnemy2.width = 20;
        finalEnemy2.height = 20;

        //Non damaging enemy 1 - white on the screen 
        noDamageEnemy1.x = 50;
        noDamageEnemy1.y = 50;
        noDamageEnemy1.width = 20;
        noDamageEnemy1.height = 20;

        //Non damaging enemy 2 - white on the screen 
        noDamageEnemy2.x = 50;
        noDamageEnemy2.y = 50;
        noDamageEnemy2.width = 20;
        noDamageEnemy2.height = 20;
        
        //Non damaging enemy 2 - white on the screen 
        noDamageEnemy3.x = 50;
        noDamageEnemy3.y = 50;
        noDamageEnemy3.width = 20;
        noDamageEnemy3.height = 20;

        //Draw start screen 
        waitForVBlank();
        drawFullScreenImageDMA(start);
        drawString(0, 20, "Press the select button to start", RED);
        drawString(10, 20, "AVOID THE RED BLOCK", RED);
        state = STARTWAIT;
        break;

      //Help with tearing and move into play state 
      case STARTWAIT:
        if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
          state = PLAY;
        }
      break;
      
      case PLAY:
        //If player selects to go back to home screen 
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          ax.select = 1;
          state = START;
          break;
        }

        //draw playing screen 
        waitForVBlank();
        fillScreenDMA(BLACK);
        drawImageDMA(ax.nonEnemy.x, ax.nonEnemy.y, ax.nonEnemy.width, ax.nonEnemy.height, nonEnemy);     
        char scoreHolder[20];
        sprintf(scoreHolder, "%d", ax.nonEnemy.movesToEnd);
        drawString(20, 30, "SCORE: ", RED);
        drawString(30, 30, scoreHolder, RED);
        
        //randomize movement of enemey 1
        if(finalEnemy.y < 150) {
          drawImageDMA(finalEnemy.x, finalEnemy.y, finalEnemy.width, finalEnemy.height, enemyPic);
          finalEnemy.y += 2;
        } else {
          finalEnemy.y = 0;
          finalEnemy.x = randint(30, 200);
        }

        //randomize movement of enemey 2
        if(finalEnemy2.y < 150) {
          drawImageDMA(finalEnemy2.x, finalEnemy2.y, finalEnemy2.width, finalEnemy2.height, enemyPic);
          finalEnemy2.x += 2;
        } else {
          finalEnemy2.x = 0;
          finalEnemy2.y = randint(30, 200);
        }

        //Randomize movement of Non damaging enemy 1
        if(noDamageEnemy1.y < 150) {
          drawImageDMA(noDamageEnemy1.x, noDamageEnemy1.y, noDamageEnemy1.width, noDamageEnemy1.height, enemyPic2);
          noDamageEnemy1.y += 4;
        } else {
          noDamageEnemy1.y = 0;
          noDamageEnemy1.x = randint(30, 200);
        }

        //Randomize movement of Non damaging enemy 1
        if(noDamageEnemy2.y < 150) {
          drawImageDMA(noDamageEnemy2.x, noDamageEnemy2.y, noDamageEnemy2.width, noDamageEnemy2.height, enemyPic2);
          noDamageEnemy2.x += 4;
        } else {
          noDamageEnemy2.x = 0;
          noDamageEnemy2.y = randint(30, 200);
        }

        //Randomize movement of Non damaging enemy 1
        if(noDamageEnemy3.y < 150) {
          drawImageDMA(noDamageEnemy3.x, noDamageEnemy3.y, noDamageEnemy3.width, noDamageEnemy3.height, enemyPic2);
          noDamageEnemy3.x += 1;
        } else {
          noDamageEnemy3.x = 5;
          noDamageEnemy3.y = randint(20, 190);
        }
        
        //If the player makes the block to the end of the screen they will win the game 
        if (ax.nonEnemy.x + ax.nonEnemy.width >= WIDTH) {
          ax.win = 1;
          state = WIN;
          break;
        }

        //Move player up
        if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons) &&  ax.nonEnemy.y > 0) {
           ax.nonEnemy.y -= 10;
           ax.nonEnemy.movesToEnd += 1;
        }
        //Move player down
        if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons) &&  ax.nonEnemy.y > 0) {
           ax.nonEnemy.y += 10;
           ax.nonEnemy.movesToEnd += 1;
        }
        //Move player left
        if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons) &&  ax.nonEnemy.y > 0) {
           ax.nonEnemy.x -= 10;
           ax.nonEnemy.movesToEnd += 1;
        }
        //Move player right
        if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons) &&  ax.nonEnemy.y > 0) {
           ax.nonEnemy.x += 10;
           ax.nonEnemy.movesToEnd += 1;
        }

        //If the player collides with enemy1 
        if ((ax.nonEnemy.x + ax.nonEnemy.width >= finalEnemy.x && ax.nonEnemy.x <= finalEnemy.x + finalEnemy.width)) {
            if ((ax.nonEnemy.y <= finalEnemy.y + ax.nonEnemy.height && ax.nonEnemy.y + ax.nonEnemy.height >= finalEnemy.y)) {
              ax.lose = 1;
              state = LOSE;
          }
        }

        //If the player collides with enemy2
        if ((ax.nonEnemy.x + ax.nonEnemy.width >= finalEnemy2.x && ax.nonEnemy.x <= finalEnemy2.x + finalEnemy2.width)) {
            if ((ax.nonEnemy.y <= finalEnemy2.y + ax.nonEnemy.height && ax.nonEnemy.y + ax.nonEnemy.height >= finalEnemy2.y)) {
              ax.lose = 1;
              state = LOSE;
          }
        }

        //Check to make sure the state is correct
        if (ax.lose == 1) {
          state = LOSE;
        } else if (ax.win == 1) {
          state = WIN;
        } else if (ax.select == 1) {
          state = START;
        } else {
          state = PLAY;
        } 
        break;

      case WIN:
        //Draw end of game image
        waitForVBlank();
        drawFullScreenImageDMA(end); //get end picture to put here 
        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
          state = START;
        }
        break;

      case LOSE:
        //Draw text and images to the losing screen 
        waitForVBlank();
        fillScreenDMA(BLACK);
        drawCenteredString(10, 100, 50, 50, "YOU LOST!", RED);
        drawCenteredString(30, 100, 50, 50, "PRESS SELECT ", RED);
        drawCenteredString(50, 100, 50, 50, "TO PLAY AGAIN", RED);

        if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) { 
          state = START;
        }
        break;
    }
    previousButtons = currentButtons;  // Store the current state of the buttons
  }
  return 0;
}
